1. swea 1244. 최대 상금

​		간단히 말하면, 주어진 숫자를 주어진 기회만큼 자릿수 별로 교환하여 최대 숫자를 얻는 것

		- 처음에 접근은 그냥 맨 위자리에 큰 수를 꽂아 넣는다 로 정했다.

```
def mp(n):
    a0 = list(n[0])
    a0 = list(map(int,list(a0)))
    a1 = int(n[1])
    b = list(map(int,list(a0)))
    b.sort(reverse = True) #b는 목표값
    opp = 0
    p = 0    
    cnt = 0
    if a0 == b:
        for i in range(a1): # 최대값에서 남은 횟수만큼 가장 작은 단위만 바꿈
            a0[-1], a0[-2] = a0[-2], a0[-1]
            return a0
    
    while(opp < a1):

        q = 0
        tmp = 0
        if a0[p] == b[p]:
            p += 1
            
        else :
            r = 0
            tmp = a0[p]
            a0[p] = b[p]
            while(q == 0):
                #print(b[p])
                if a0[-1-r] != b[p] :
                    r += 1
                else :
                    a0[-1-r] = tmp
                    q += 1
                    opp += 1
        
        if a0 == b:
            for i in range(a1 - opp): # 최대값에서 남은 횟수만큼 가장 작은 단위만 바꿈
                a0[-1], a0[-2] = a0[-2], a0[-1]
                return a0
    
    return a0
```



여기서 기본적으로 작동은 하지만, 예외에 걸린다.

예를 들어 32888같은 경우 두번 바꾸게 될경우 88832가 가장 큰 숫자가 될것이다. 하지만 내가 짠 알고리즘에 따르면 88823이 되어버린다. 간단히 자릿수 별로 바꿔버리니 이런 일이 됐다.

또 77770같은 경우 한번 바꾸게 될경우 77770이 가장 큰 숫자인데, 알고리즘상 77707이 되어버린다.



이에 대한 해결방안을 생각해봐야 하는데,,

두 가지 오류의 원인은 모두 같은 숫자가 연속되는 경우로 인해 발생된다. 여기서 생각해 볼 수 있는 것은 

첫째 같은 숫자의 교환이 이루어 질때, 같은 숫자가 반복 될 경우에는 각각 교환하는 것이 아닌 한꺼번에 묶어서 교환이 이루어져야 할 듯하다.

둘 째 이미 최대값을 완성시킨 경우에는 중복된 숫자가 있을 경우 그 둘이 바뀔 수 있도록 해야한다.

위를 토대로 다시 짜보자

모르겠다

